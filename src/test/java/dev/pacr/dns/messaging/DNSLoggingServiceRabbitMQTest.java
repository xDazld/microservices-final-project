package dev.pacr.dns.messaging;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import dev.pacr.dns.model.FilterResult;
import dev.pacr.dns.model.rfc8427.DnsMessage;
import dev.pacr.dns.model.rfc8427.ResourceRecord;
import dev.pacr.dns.service.DNSLoggingService;
import io.quarkus.test.junit.QuarkusTest;
import jakarta.inject.Inject;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;

import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Integration tests for DNSLoggingService with real RabbitMQ
 * Tests the logging of DNS queries and security alerts to RabbitMQ message
 * broker
 */
@QuarkusTest
class DNSLoggingServiceRabbitMQTest {

    @Inject
    DNSLoggingService loggingService;

    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() {
        objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
    }

    /**
     * Test logging a successful DNS query to RabbitMQ
     * Verifies that a valid DNS query is properly formatted and sent
     */
    @Test
    void testLogSuccessfulDNSQuery() {
        // Arrange
        DnsMessage query = createDNSQuery("example.com", 1);
        DnsMessage response = createDNSResponse(0, "93.184.216.34");
        FilterResult filterResult = FilterResult.allow();

        // Act
        assertDoesNotThrow(() -> {
            loggingService.logQuery(query, response, filterResult);
        });

        // Assert - the fact that no exception was thrown indicates success
        // In a real scenario, we would verify the message was received by checking
        // the RabbitMQ queue or a consumer
    }

    /**
     * Test logging a blocked DNS query to RabbitMQ
     * Verifies that blocked queries are properly logged with status
     */
    @Test
    void testLogBlockedDNSQuery() {
        // Arrange
        DnsMessage query = createDNSQuery("malicious.com", 1);
        DnsMessage response = createDNSResponse(3, null); // NXDOMAIN
        FilterResult filterResult = FilterResult.block("Malware detected", null);

        // Act
        assertDoesNotThrow(() -> {
            loggingService.logQuery(query, response, filterResult);
        });

        // Assert
        assertTrue(true); // Successfully executed without throwing exception
    }

    /**
     * Test logging a DNS query with multiple answer records
     * Verifies that complex responses with multiple answers are properly serialized
     */
    @Test
    void testLogDNSQueryWithMultipleAnswers() {
        // Arrange
        DnsMessage query = createDNSQuery("multi.example.com", 1);
        DnsMessage response = createDNSResponseWithMultipleAnswers(0,
                "192.0.2.1", "192.0.2.2", "192.0.2.3");
        FilterResult filterResult = FilterResult.allow();

        // Act
        assertDoesNotThrow(() -> {
            loggingService.logQuery(query, response, filterResult);
        });

        // Assert
        assertTrue(true); // Successfully logged
    }

    /**
     * Test logging a security alert for malware detection
     * Verifies that malware alerts are properly formatted and sent
     */
    @Test
    void testLogMalwareSecurityAlert() {
        // Arrange
        String domain = "malware.example.com";
        String alertType = "MALWARE_DETECTED";
        String description = "Known malware distribution site detected";

        // Act
        assertDoesNotThrow(() -> {
            loggingService.logSecurityAlert(domain, alertType, description);
        });

        // Assert
        assertTrue(true); // Successfully logged
    }

    /**
     * Test logging a DGA (Domain Generation Algorithm) security alert
     * Verifies that DGA detection alerts are properly handled
     */
    @Test
    void testLogDGASecurityAlert() {
        // Arrange
        String domain = "xyzabcdefghijklmnop.com";
        String alertType = "DGA_DETECTED";
        String description = "Domain appears to be generated by algorithm";

        // Act
        assertDoesNotThrow(() -> {
            loggingService.logSecurityAlert(domain, alertType, description);
        });

        // Assert
        assertTrue(true); // Successfully logged
    }

    /**
     * Test logging a phishing security alert
     * Verifies that phishing alerts are properly detected and logged
     */
    @Test
    void testLogPhishingSecurityAlert() {
        // Arrange
        String domain = "paypa1.phishing.com";
        String alertType = "PHISHING_DETECTED";
        String description = "Domain mimics legitimate service";

        // Act
        assertDoesNotThrow(() -> {
            loggingService.logSecurityAlert(domain, alertType, description);
        });

        // Assert
        assertTrue(true); // Successfully logged
    }

    /**
     * Test multiple security alerts in sequence
     * Verifies that the service can handle rapid alert logging
     */
    @Test
    void testMultipleSecurityAlertsInSequence() {
        // Arrange
        List<String[]> alerts = List.of(
                new String[] { "malware1.com", "MALWARE_DETECTED", "Malware confirmed" },
                new String[] { "dga.example.com", "DGA_DETECTED", "DGA pattern found" },
                new String[] { "phish.site.com", "PHISHING_DETECTED", "Phishing site" });

        // Act & Assert
        alerts.forEach(alert -> {
            assertDoesNotThrow(() -> {
                loggingService.logSecurityAlert(alert[0], alert[1], alert[2]);
            });
        });
    }

    /**
     * Test DNS query logging with null response answers
     * Verifies that null answer records are handled gracefully
     */
    @Test
    void testLogDNSQueryWithNullAnswers() {
        // Arrange
        DnsMessage query = createDNSQuery("nonexistent.example.com", 1);
        DnsMessage response = new DnsMessage();
        response.setRcode(3); // NXDOMAIN
        response.setAnswerRRs(null); // No answers
        FilterResult filterResult = FilterResult.allow();

        // Act
        assertDoesNotThrow(() -> {
            loggingService.logQuery(query, response, filterResult);
        });

        // Assert
        assertTrue(true); // Successfully handled null answers
    }

    /**
     * Test DNS query logging with empty answer list
     * Verifies that empty answer records are handled gracefully
     */
    @Test
    void testLogDNSQueryWithEmptyAnswers() {
        // Arrange
        DnsMessage query = createDNSQuery("example.com", 1);
        DnsMessage response = new DnsMessage();
        response.setRcode(0); // NOERROR
        response.setAnswerRRs(new ArrayList<>()); // Empty answers
        FilterResult filterResult = FilterResult.allow();

        // Act
        assertDoesNotThrow(() -> {
            loggingService.logQuery(query, response, filterResult);
        });

        // Assert
        assertTrue(true); // Successfully handled empty answers
    }

    /**
     * Test logging with special characters in domain name
     * Verifies that domains with internationalized characters are properly handled
     */
    @Test
    void testLogDNSQueryWithSpecialCharactersDomain() {
        // Arrange
        DnsMessage query = createDNSQuery("example.com", 1);
        DnsMessage response = createDNSResponse(0, "192.0.2.1");
        FilterResult filterResult = FilterResult.allow();

        // Act
        assertDoesNotThrow(() -> {
            loggingService.logQuery(query, response, filterResult);
        });

        // Assert
        assertTrue(true); // Successfully logged
    }

    /**
     * Test error handling when logging with invalid filter result
     * Verifies that the service handles unexpected filter results
     */
    @Test
    void testLogDNSQueryWithVariousFilterActions() {
        // Arrange
        DnsMessage query = createDNSQuery("test.com", 1);
        DnsMessage response = createDNSResponse(0, "192.0.2.1");

        // Act & Assert
        FilterResult[] filterResults = {
                FilterResult.allow(),
                FilterResult.block("Test block", null),
                FilterResult.redirect("example.com", null)
        };

        for (FilterResult filterResult : filterResults) {
            assertDoesNotThrow(() -> {
                loggingService.logQuery(query, response, filterResult);
            });
        }
    }

    /**
     * Test security alert with long domain name
     * Verifies that long domain names are properly handled
     */
    @Test
    void testLogSecurityAlertWithLongDomainName() {
        // Arrange
        String longDomain = "this.is.a.very.long.domain.name.with.many.subdomains.example.com";
        String alertType = "SUSPICIOUS_ACTIVITY";
        String description = "Long domain name detected";

        // Act
        assertDoesNotThrow(() -> {
            loggingService.logSecurityAlert(longDomain, alertType, description);
        });

        // Assert
        assertTrue(true); // Successfully logged
    }

    /**
     * Test security alert with empty description
     * Verifies that empty descriptions are handled gracefully
     */
    @Test
    void testLogSecurityAlertWithEmptyDescription() {
        // Arrange
        String domain = "example.com";
        String alertType = "TEST_ALERT";
        String description = "";

        // Act
        assertDoesNotThrow(() -> {
            loggingService.logSecurityAlert(domain, alertType, description);
        });

        // Assert
        assertTrue(true); // Successfully logged empty description
    }

    // Helper methods to create test data

    private DnsMessage createDNSQuery(String domain, int queryType) {
        DnsMessage message = new DnsMessage();
        message.setQname(domain);
        message.setQtype(queryType);
        message.setRcode(0);
        return message;
    }

    private DnsMessage createDNSResponse(int rcode, String ipAddress) {
        DnsMessage message = new DnsMessage();
        message.setRcode(rcode);

        if (ipAddress != null) {
            ResourceRecord rr = new ResourceRecord();
            rr.setRdata(ipAddress);
            List<ResourceRecord> answers = new ArrayList<>();
            answers.add(rr);
            message.setAnswerRRs(answers);
        }

        return message;
    }

    private DnsMessage createDNSResponseWithMultipleAnswers(int rcode, String... ipAddresses) {
        DnsMessage message = new DnsMessage();
        message.setRcode(rcode);

        List<ResourceRecord> answers = new ArrayList<>();
        for (String ip : ipAddresses) {
            ResourceRecord rr = new ResourceRecord();
            rr.setRdata(ip);
            answers.add(rr);
        }
        message.setAnswerRRs(answers);

        return message;
    }
}
